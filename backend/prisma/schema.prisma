generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  name     String?
  password String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FakePerson {
  id String @id @default(uuid())

  firstName String  @map("first_name")
  lastName  String  @map("last_name")
  fullName  String? @map("full_name")
  email     String  @unique

  company       String
  companyDomain String? @map("company_domain")
  role          String
  industry      String

  notes         String? @db.Text
  personalNotes String? @map("personal_notes") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("fake_persons")
}

enum ProcessingStatus {
  NONE
  PROCESSING
  COMPLETED
  FAILED
}

enum RoutingRuleType {
  KEYWORD
  EMAIL
  FULL_NAME
}

enum RoutingMatchMode {
  EXACT
  CONTAINS
  REGEX
}

enum RoutingAction {
  SENTIMENT_ONLY
  SUMMARISE
}

enum RedactionEntityType {
  EMAIL
  NAME
  COMPANY
  PHONE
  OTHER
}

model EmailThread {
  id                String   @id @default(cuid())
  accountId         String
  normalizedSubject String
  conversationId    String?  @unique
  messageCount      Int      @default(0)
  firstMessageAt    DateTime
  lastMessageAt     DateTime

  summary      String? @db.Text
  actions      Json?
  topicTags    Json?
  hasAISummary Boolean @default(false)

  account  Account         @relation(fields: [accountId], references: [id])
  messages ReceivedEmail[]
  insights AccountInsight[]
  sentimentFacts SentimentFact[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([accountId])
  @@index([accountId, normalizedSubject])
  @@map("email_threads")
}

model Account {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String?
  company      String?
  totalEmails  Int       @default(0)
  threadCount  Int       @default(0)
  firstEmailAt DateTime?
  lastEmailAt  DateTime?

  personal       Json?
  business       Json?
  sentimentTrend Json?
  hasAIProfile   Boolean @default(false)

  emails  ReceivedEmail[]
  threads EmailThread[]
  insights AccountInsight[]
  sentimentFacts SentimentFact[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@map("accounts")
}

model ReceivedEmail {
  id                            String           @id @default(cuid())
  subject                       String
  body                          Json
  bodyPreview                   String?
  from_                         Json             @map("from")
  sender                        Json?
  toRecipients                  Json
  ccRecipients                  Json?
  bccRecipients                 Json?
  replyTo                       Json?
  sentDateTime                  DateTime?
  receivedDateTime              DateTime?
  internetMessageId             String?          @unique
  hasAttachments                Boolean          @default(false)
  isRead                        Boolean          @default(false)
  webLink                       String?
  singleValueExtendedProperties Json?
  rawResponse                   Json?
  processingStatus              ProcessingStatus @default(NONE)
  accountId                     String?
  threadId                      String?
  hasAccount                    Boolean          @default(false)
  hasThread                     Boolean          @default(false)
  hasAnalysis                   Boolean          @default(false)
  processedAt                   DateTime?
  analyzedAt                    DateTime?

  account Account?     @relation(fields: [accountId], references: [id])
  thread  EmailThread? @relation(fields: [threadId], references: [id])

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  EmailSpamCheck EmailSpamCheck[]
  sentimentFacts SentimentFact[]

  @@index([receivedDateTime])
  @@index([processingStatus])
  @@index([accountId])
  @@index([threadId])
  @@index([sentDateTime])
  @@map("received_emails")
}

model EmailSpamCheck {
  id         String   @id @default(cuid())
  emailId    String
  isSpam     Boolean
  confidence Float?
  modelUsed  String?
  checkedAt  DateTime @default(now())

  email ReceivedEmail @relation(fields: [emailId], references: [id])

  @@index([emailId])
  @@map("email_spam_checks")
}

model QueueConfig {
  id        String  @id @default(uuid())
  queueName String  @unique
  enabled   Boolean @default(false)
  cronPattern String?

  concurrency   Int @default(1)
  maxJobsPerMin Int @default(10)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("queue_configs")
}

model RedactionAlias {
  id          String               @id @default(uuid())
  placeholder String               @unique
  entityType  RedactionEntityType
  realValue   String
  hash        String?
  scope       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([entityType])
  @@index([hash, entityType, scope])
  @@map("redaction_aliases")
}

model AccountInsight {
  id        String   @id @default(uuid())
  accountId String
  threadId  String?
  payload   Json

  createdAt DateTime @default(now())

  account Account   @relation(fields: [accountId], references: [id])
  thread  EmailThread? @relation(fields: [threadId], references: [id])

  @@index([accountId])
  @@index([threadId])
  @@map("account_insights")
}

model SentimentFact {
  id         String   @id @default(uuid())
  accountId  String
  threadId   String?
  emailId    String?
  overall    String
  score      Float
  confidence Float
  riskTags   Json
  capturedAt DateTime @default(now())

  account Account   @relation(fields: [accountId], references: [id])
  thread  EmailThread? @relation(fields: [threadId], references: [id])
  email   ReceivedEmail? @relation(fields: [emailId], references: [id])

  @@index([accountId])
  @@index([threadId])
  @@index([emailId])
  @@map("sentiment_facts")
}

model RoutingPolicyRule {
  id        String           @id @default(uuid())
  type      RoutingRuleType
  action    RoutingAction
  value     String
  matchMode RoutingMatchMode @default(EXACT)
  enabled   Boolean          @default(true)
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  @@index([type])
  @@index([enabled])
  @@map("routing_policy_rules")
}
